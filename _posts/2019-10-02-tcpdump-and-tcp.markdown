---
layout: post
title: "利用tcpdump分析TCP/IP协议报文"
subtitle: ""
author: "zy"
header-img: "img/post-bg-os-metro.jpg"
catalog: true
tags:
  - 协议
  - Linux
---

## 引用

最近在做的项目的时候，出现了一个现象：我们的服务部署在k8s上，集群外部的七层负载均衡做了改版之后，服务响应特别慢，时延达到20s。但是从服务的监控工具new relic来看，服务响应的时长基本的都在100ms以内。这时候陷入了僵局，云平台的同事认为网关没有问题，我们坚持自己的服务是ok的。最终依赖于tcpdump工具对http请求进行抓包，发现服务响应时间和new relic的响应时间基本是一致的。最终定位到的原因是由于http的协议版本过低导致响应时间过长, 这是一个关于长链接和短链接的问题，我们后面再讨论。

tcpdump确实是很优秀的调试工具，一直想学习，但一直无从下手。其次是对于计算机网络这块，一直都是死记硬背，记忆效果很差。所以趁着这次机会，利用tcpdump协议来分析TCP/IP协议报文。

## 报文获取

关于TCP报文，文章一大堆，就像教科书一样枯燥无味。那现在我们就从另一个角度切入TCP/IP, 让它可以以一种具象化的形式呈现在我们眼前。先启动redis-server, 通过监听网卡的环回接口（lo0），获取协议报文：

本地局域网ip是192.168.0.104，启动redis server，默认端口是6379。通过tcpdump工具进行抓取数据包，命令如下: 
```
tcpdump -w /tmp/logs -i lo0 port 10000 -s0
``` 
在本地telnet redis server, 发送一个ping, 会得到服务端的pong回复:
```
telnet 192.168.0.104 6379
```
停止抓包，然后用tcpdump读取这个数据包（-x以16进制形式展示，便于后面分析）

```
tcpdump -r /tmp/logs -nn -A -x| cat -
```

## 报文分析

在这里，我们先忽略表示层和会话层，来分析5层协议, 其数据进入协议栈的封装过程为：
```
应用层 ---> 传输层 ---> 网络层 ---> 数据链路层 ---> 物理层
```
当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层，直到被当作一串比特流送入网络。其中每一层都要增加一些首部信息(有时候还要增加尾部信息)。在这里需要注意的是：TCP传给IP的数据单元称为TCP报文或简称为TCP段(TCP segment)；UDP传给IP的信息单元称作UDP数据报(UDP datagram)。IP传给网络接口层的数据单元称为IP数据报(IP datagram)。通过以太网传输的比特称为帧(Frame)。

因为抓到的数据包是redis的服务，因此传输层为TCP协议，也是我们今天要分析的对象。IP数据报的整体结构如下：

![](/img/in-post/post-os-network/post-tcp-ip.jpeg)

第一次握手的数据包如下：
```
00:07:52.486825 IP 192.168.0.104.58251 > 192.168.0.104.6379: Flags [SEW], seq 1700854419, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 1153012392 ecr 0,sackOK,eol], length 0
	0x0000:  4510 0040 5993 4000 4006 0000 c0a8 0068
	0x0010:  c0a8 0068 e38b 18eb 6560 fa93 0000 0000
	0x0020:  b0c2 ffff 8253 0000 0204 3fd8 0103 0305
	0x0030:  0101 080a 44b9 92a8 0000 0000 0402 0000
```

##### 网络层解析

在解析数据包之前，我们需要先把IP协议搬出来。极其枯燥无味的协议视图又来了，我们这次要做的是将抓到的数据和协议的字段一一对应起来，加深记忆。

![](/img/in-post/post-os-network/ip-network.jpeg)

可以看到， IP报文的头部采用的是固定长度（20 bytes）+ 可变长度构成。接着我们继续对数据报进行分析：

| 数据表示   | 协议字段  |字段大小| 数据解释|
|  :----:  | :----:  |:----:|:----:|
| 0x4  | ip协议版本 | 4 bit | 0x4表示IPv4 |
| 0x5  | ip首部长度  |4 bit | 该字段表示的单位是4 bytes, 所以这个头部的包有5*4=20(byte)，也可以推算出这个IP数据报没有可选字段。4 bit可以表示最大的数为0xF, 因此，IP数据包头部的可以表示的最大长度为60(byte)。|
|0x10 | 服务类型 TOS|8 bit|该段数据组成为 3bit（优先权字段(现已被忽略)） + 4bit （TOS 字段） + 1bit （保留字段(须为0))。4bit TOS 字段分别表示最小时延、最大吞吐量、最高可用性和最小费用。四个字段只能将其中之一置为1 ，全为0表示一般服务。可以看到，本报文TOS字段为最小时延。|
|0x0040| IP报文总长度 | 16 bit| 这个字段使用的单位是字节，换算下来，该数据包的长度为64字节，我们可以数一下上文中数据包的长度，恰好是64 byte。从占位数来算，从占位数来算， IP数据报最长为2^16=65535B，但大部分网络的链路层 MTU（最大传输单元）没有这么大，一些上层协议或主机也不会接受这么大的，故超长IP数据报在传输时会被分片。|
| 0x5993  | 标识 | 16 bit | 唯一地标识主机发送的每一个数据报，通常每发送一个数据报，它的值就+1。当IP数据报文分片时，该标识字段值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。|
| 0x4000  | 3bit 标志 + 13bit 片偏移 | 16 bit |3bit标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit片位移表示本分片在原先数据报文中相对首位的偏移位（byte）。|
| 0x40  | 生存时间TTL | 8 bit | IP数据报所允许通过的路由器的最大数量，每经过一个路由器，TTL减1，当为0时，路由器会将该数据包抛弃。发送ICMP回显应答时，通常会把TTL设为255。TTL可以防止数据报陷入路由循环，本报文中，该值为64。 |
| 0x06  | 协议 | 8 bit | 指出IP报文携带的数据使用的是哪种协议，以便目的主机的网络层可以知道要将数据上交到哪个进程。TCP的协议号为6，UDP的协议号为17，ICMP的协议号为1，IGMP的协议号为2。|
| 0x0000  | IP 首部校验和 | 16 bit | 检验和是16位的错误检测字段。目的主机和网络中的每个网关都要重新计算报头的校验和，如果首部在传输过程中没有发生任何差错, 那么接收方计算的结果应该为全1，如果结果不是全1(即检验错误)，那么网络层久丢弃收到的数据报，但是不生成差错报文，由上层去发现数据并进行重传。|
| 0xc0a80068  | 源地址信息 | 32 bit | 使用ruby的[ss].pack("H*").unpack("C*") ==> [192, 168, 0, 104], pack转换为二进制表示，然后再使用无符号字符表示。|
| 0xc0a80068  | 目的地址信息 | 32 bit | 使用ruby的[ss].pack("H*").unpack("C*") ==> [192, 168, 0, 104], pack转换为二进制表示，然后再使用无符号字符表示。|

##### 传输层解析

本报文携带的数据是TCP协议，因此我们开始分析TCP协议。和上面的IP报文一样，TCP报文也是采用固定长度（20B）+ 可变长度的形式。我们还是先来看看TCP协议的格式：
![](/img/in-post/post-os-network/tcp-network.jpeg)

| 数据表示   | 协议字段  |字段大小| 数据解释|
|  :----:  | :----:  |:----:|:----:|
| 0xe38b  | 源端口 | 16 bit | 解析得到58251，16 bit决定了端口号的最大值为65535 |
| 0x18eb  | 目的端口 | 16 bit | 解析得到6379，符合预期 |
| 0x6560fa93  | 序号 | 32 bit | 与tcpdump中的seq一致，值为1700854419 |
| 0x00000000  | 确认号 | 32 bit | 可以看到，第一个握手包为的ack为0 |
| 0xb  | TCP 报文首部长度 | 8 bit | 11 * 4 = 44B, 同IP头部类似，最大长度为60B |
|0b000000| TCP保留位 |6 bit|保留为今后使用，但目前应置为0|
|0b011000| TCP标志位 | 6 bit | 上图可以看到，从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。|
| 0xffff  | 滑动窗口大小 | 16 bit | 解析得到65535，为允许的最大值 |
| 0x8253  | 校验和 | 16 bit | 由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃|
| 0x0000  | 紧急指针 | 16 bit | 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 |

TCP协议的可选项，并不是关注的重点，并且这段报文不存在可选项，所以暂时忽略。

##### 数据部分

根据上面的分析，该报文的长度为64B, IP头长度为20B, TCP报文的首部长度为44B。可见此段报文并没有传输应用层的数据。

## 总结

这篇博文是针对TCP/IP的报文，按照协议字段进行了简单地分析。但是还有许多待补充的地方：
1. 只是针对TCP/IP的报文字段进行了分析，并没有对三次握手的动作进行分析
2. 没有分析具体的应用层数据
3. 一些协议字段理解得也不是很透彻，比如说TCP协议中的标识位，紧急指针等

## 引用
* [tcpdump/wireshark 抓包及分析](https://arthurchiao.github.io/blog/tcpdump-practice-zh/)
* [计算机网络基础](https://www.cnblogs.com/xdyixia/p/9275246.html)
* [从tcpdump抓包看TCP/IP协议](https://segmentfault.com/a/1190000015044878?utm_source=tag-newest)




